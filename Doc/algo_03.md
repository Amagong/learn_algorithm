## 03 : 코딩과 디버깅

### 3.1 코딩의 중요성

### 3.2 종은 코드
    - 간결한 코드 (버그)
    - 코드 재사용 (3번이상 사용하는 것들은 함수, 클래스 분리)
    - 표준 라이브러리 숙지 (vector, queue, stack, list, hash, ..)
    - 항상 같은 형태로 프로그램 작성하기 (예: binary search, graph search (dfs, bfs), 2차원 평면구조, ..)
        -> 자주 사용하는 패턴의 코드들은 검증된 형태로 작성해 보고 항상 같은 패턴으로 사용 (버그를 줄인다.)
    - 일관적이고 명료한 명명법
    - 입출력 자료(데이터)는 항상 정규화 (예: 실수, 2차원 벡터, 시간, ...)
    - 코드와 데이터 분리

### 3.3 자주하는 실수
    - 오버플로우 체크
    - 배열 범위 밖의 원소 접근
        -> 일관되지 않은 범위 표현 ( open interval, closed interval, half-open interval )
        -> half-open interval 사용 : [lo, hi)
        -> STL에서도 begin(), end()에서 end()는 마지막원소의 다음
        -> binary search나 기타 재귀 호출시 주의 필요 !!
    - Off-by-one : 하나 빠드리기
        -> 최소 입력이 주어졌을 때 제대로 동작하는 형태인지 확인 필요
        -> 예: A[i]..A[j]의 평균은 j-i+1 로 나누어야 한다.
    - 오타
    - 스택 오버플로우 : 재귀호출에서 주의해야 함.
    - 다차원 배열의 인덱스 순서 바꿔 쓰기 !! : 동적계획법에서 헷갈리는 경우가 다수 있음
    - 잘못된 비교 : 모든 비교를 다 하는가? Exclusive Complete하게 비교해야. (if-else)
    - 최대 최소 예외
    - 연산자 우선 순위 오해
    - 너무 느린 입출력 방식 선택 (cin는 2배이상 느리다.)
        -> std::ios_base::sync_with_stdio(false)
    - 변수 초기화 : !!

### 3.4 디버깅
    - 프로그램 계산 중간값을 출력
    - 스캐폴링 [TODO]

### 3.5 변수 범위
    - 너무 큰 결과
        -> long long (64bit), scanf(%lld), printf(%lld)
    - 너무 큰 중간값
        -> 계산순서를 통한 제거 : * / --> / 먼저하고 *
    - 초기값으로 무한대 ( INF = 987654321 )
    - 자료형의 프로모션 주의

### 3.6 실수 자료형 [TODO]
